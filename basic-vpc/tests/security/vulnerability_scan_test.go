package test

import (
	"fmt"
	"strings"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/ec2"
	"github.com/aws/aws-sdk-go/service/iam"
	"github.com/gruntwork-io/terratest/modules/terraform"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestVulnerabilityScanInfrastructure(t *testing.T) {
	t.Parallel()

	terraformOptions := &terraform.Options{
		TerraformDir: "../../",
		Vars: map[string]interface{}{
			"environment":        "security-scan",
			"allowed_http_cidrs": []string{"10.0.0.0/8"},
			"allowed_ssh_cidrs":  []string{"10.0.0.0/8"},
		},
	}

	defer terraform.Destroy(t, terraformOptions)
	terraform.InitAndApply(t, terraformOptions)

	sess := session.Must(session.NewSession(&aws.Config{
		Region: aws.String("us-east-1"),
	}))

	// Test 1: Check for exposed security groups
	t.Log("Scanning for exposed security groups...")
	exposedSGs := scanForExposedSecurityGroups(t, sess)
	assert.Empty(t, exposedSGs, "No security groups should allow unrestricted access")

	// Test 2: Check for unencrypted resources
	t.Log("Scanning for unencrypted resources...")
	unencryptedResources := scanForUnencryptedResources(t, terraformOptions)
	assert.Empty(t, unencryptedResources, "All resources should be encrypted")

	// Test 3: Check for overly permissive IAM policies
	t.Log("Scanning for overly permissive IAM policies...")
	permissivePolicies := scanForPermissiveIAM(t, sess)
	assert.Empty(t, permissivePolicies, "No overly permissive IAM policies should exist")

	// Test 4: Check for public S3 buckets
	t.Log("Scanning for public S3 buckets...")
	publicBuckets := scanForPublicS3Buckets(t, sess)
	assert.Empty(t, publicBuckets, "No S3 buckets should be publicly accessible")

	// Test 5: Check for vulnerable instance configurations
	t.Log("Scanning for vulnerable instance configurations...")
	vulnerableInstances := scanForVulnerableInstances(t, terraformOptions)
	assert.Empty(t, vulnerableInstances, "No instances should have vulnerable configurations")
}

func TestVulnerabilityScanNetworkSecurity(t *testing.T) {
	t.Parallel()

	terraformOptions := &terraform.Options{
		TerraformDir: "../../",
		Vars: map[string]interface{}{
			"environment":        "security-scan",
			"allowed_http_cidrs": []string{"10.0.0.0/8"},
			"allowed_ssh_cidrs":  []string{"10.0.0.0/8"},
		},
	}

	defer terraform.Destroy(t, terraformOptions)
	terraform.InitAndApply(t, terraformOptions)

	sess := session.Must(session.NewSession(&aws.Config{
		Region: aws.String("us-east-1"),
	}))
	ec2Svc := ec2.New(sess)

	// Test 1: Check for security groups with dangerous rules
	t.Log("Scanning for dangerous security group rules...")
	dangerousRules := scanForDangerousSecurityGroupRules(t, ec2Svc, terraformOptions)
	assert.Empty(t, dangerousRules, "No dangerous security group rules should exist")

	// Test 2: Check for NACL misconfigurations
	t.Log("Scanning for NACL misconfigurations...")
	naclIssues := scanForNACLErrors(t, ec2Svc, terraformOptions)
	assert.Empty(t, naclIssues, "No NACL misconfigurations should exist")

	// Test 3: Check for VPC Flow Logs configuration
	t.Log("Verifying VPC Flow Logs configuration...")
	flowLogsStatus := verifyVPCFlowLogs(t, terraformOptions)
	assert.True(t, flowLogsStatus, "VPC Flow Logs should be properly configured")
}

func TestVulnerabilityScanAccessControl(t *testing.T) {
	t.Parallel()

	terraformOptions := &terraform.Options{
		TerraformDir: "../../",
		Vars: map[string]interface{}{
			"environment":        "security-scan",
			"allowed_http_cidrs": []string{"10.0.0.0/8"},
			"allowed_ssh_cidrs":  []string{"10.0.0.0/8"},
		},
	}

	defer terraform.Destroy(t, terraformOptions)
	terraform.InitAndApply(t, terraformOptions)

	sess := session.Must(session.NewSession(&aws.Config{
		Region: aws.String("us-east-1"),
	}))
	iamSvc := iam.New(sess)

	// Test 1: Check for root account usage
	t.Log("Scanning for root account usage...")
	rootUsage := scanForRootAccountUsage(t, iamSvc)
	assert.False(t, rootUsage, "Root account should not be used")

	// Test 2: Check for unused IAM users/roles
	t.Log("Scanning for unused IAM resources...")
	unusedIAM := scanForUnusedIAMResources(t, iamSvc)
	assert.Empty(t, unusedIAM, "No unused IAM resources should exist")

	// Test 3: Check for password policies
	t.Log("Verifying IAM password policies...")
	passwordPolicy := verifyPasswordPolicy(t, iamSvc)
	assert.True(t, passwordPolicy, "Strong password policy should be enforced")
}

func TestVulnerabilityScanCompliance(t *testing.T) {
	t.Parallel()

	terraformOptions := &terraform.Options{
		TerraformDir: "../../",
		Vars: map[string]interface{}{
			"environment":        "security-scan",
			"allowed_http_cidrs": []string{"10.0.0.0/8"},
			"allowed_ssh_cidrs":  []string{"10.0.0.0/8"},
		},
	}

	defer terraform.Destroy(t, terraformOptions)
	terraform.InitAndApply(t, terraformOptions)

	// Test 1: Check CIS compliance
	t.Log("Scanning for CIS compliance violations...")
	cisViolations := scanForCISCompliance(t, terraformOptions)
	assert.Empty(t, cisViolations, "No CIS compliance violations should exist")

	// Test 2: Check for security headers
	t.Log("Verifying security headers configuration...")
	securityHeaders := verifySecurityHeaders(t, terraformOptions)
	assert.True(t, securityHeaders, "Security headers should be properly configured")

	// Test 3: Check for logging configuration
	t.Log("Verifying logging configuration...")
	loggingConfig := verifyLoggingConfiguration(t, terraformOptions)
	assert.True(t, loggingConfig, "Comprehensive logging should be configured")
}

// Helper functions for vulnerability scanning

func scanForExposedSecurityGroups(t *testing.T, sess *session.Session) []string {
	ec2Svc := ec2.New(sess)

	result, err := ec2Svc.DescribeSecurityGroups(&ec2.DescribeSecurityGroupsInput{})
	require.NoError(t, err)

	var exposedSGs []string
	for _, sg := range result.SecurityGroups {
		for _, permission := range sg.IpPermissions {
			for _, ipRange := range permission.IpRanges {
				if *ipRange.CidrIp == "0.0.0.0/0" {
					exposedSGs = append(exposedSGs, *sg.GroupId)
					break
				}
			}
		}
	}

	return exposedSGs
}

func scanForUnencryptedResources(t *testing.T, terraformOptions *terraform.Options) []string {
	var unencrypted []string

	// Check EBS volumes
	publicEncrypted := terraform.Output(t, terraformOptions, "public_instance_encrypted")
	privateEncrypted := terraform.Output(t, terraformOptions, "private_instance_encrypted")

	if publicEncrypted != "true" {
		unencrypted = append(unencrypted, "public-instance-ebs")
	}
	if privateEncrypted != "true" {
		unencrypted = append(unencrypted, "private-instance-ebs")
	}

	return unencrypted
}

func scanForPermissiveIAM(t *testing.T, sess *session.Session) []string {
	iamSvc := iam.New(sess)

	result, err := iamSvc.ListRoles(&iam.ListRolesInput{})
	require.NoError(t, err)

	var permissivePolicies []string
	for _, role := range result.Roles {
		// Check for wildcard permissions
		if strings.Contains(*role.RoleName, "*") ||
			strings.Contains(*role.RoleName, "admin") ||
			strings.Contains(*role.RoleName, "Admin") {
			permissivePolicies = append(permissivePolicies, *role.RoleName)
		}
	}

	return permissivePolicies
}

func scanForPublicS3Buckets(t *testing.T, sess *session.Session) []string {
	// This would require S3 service scanning
	// For this test, we'll return empty as S3 buckets are handled separately
	return []string{}
}

func scanForVulnerableInstances(t *testing.T, terraformOptions *terraform.Options) []string {
	var vulnerable []string

	// Check instance types for known vulnerabilities
	publicInstanceType := terraform.Output(t, terraformOptions, "public_instance_type")
	privateInstanceType := terraform.Output(t, terraformOptions, "private_instance_type")

	// t3.micro is generally considered secure
	if publicInstanceType != "t3.micro" {
		vulnerable = append(vulnerable, "public-instance-type")
	}
	if privateInstanceType != "t3.micro" {
		vulnerable = append(vulnerable, "private-instance-type")
	}

	return vulnerable
}

func scanForDangerousSecurityGroupRules(t *testing.T, ec2Svc *ec2.EC2, terraformOptions *terraform.Options) []string {
	var dangerous []string

	// Check if security groups allow dangerous ports
	publicSGID := terraform.Output(t, terraformOptions, "public_security_group_id")

	sgResult, err := ec2Svc.DescribeSecurityGroups(&ec2.DescribeSecurityGroupsInput{
		GroupIds: []*string{aws.String(publicSGID)},
	})
	require.NoError(t, err)

	for _, sg := range sgResult.SecurityGroups {
		for _, permission := range sg.IpPermissions {
			if *permission.FromPort == 3389 || // RDP
				*permission.FromPort == 1433 || // MSSQL
				*permission.FromPort == 3306 { // MySQL
				dangerous = append(dangerous, fmt.Sprintf("SG-%s:port-%d", *sg.GroupId, *permission.FromPort))
			}
		}
	}

	return dangerous
}

func scanForNACLErrors(t *testing.T, ec2Svc *ec2.EC2, terraformOptions *terraform.Options) []string {
	var issues []string

	// Check NACL configurations
	publicNACLID := terraform.Output(t, terraformOptions, "public_nacl_id")
	privateNACLID := terraform.Output(t, terraformOptions, "private_nacl_id")

	naclIDs := []*string{aws.String(publicNACLID), aws.String(privateNACLID)}

	for _, naclID := range naclIDs {
		naclResult, err := ec2Svc.DescribeNetworkAcls(&ec2.DescribeNetworkAclsInput{
			NetworkAclIds: []*string{naclID},
		})
		require.NoError(t, err)

		for _, nacl := range naclResult.NetworkAcls {
			for _, entry := range nacl.Entries {
				// Check for overly permissive rules
				if *entry.RuleAction == "allow" && *entry.CidrBlock == "0.0.0.0/0" {
					issues = append(issues, fmt.Sprintf("NACL-%s:rule-%d", *nacl.NetworkAclId, *entry.RuleNumber))
				}
			}
		}
	}

	return issues
}

func verifyVPCFlowLogs(t *testing.T, terraformOptions *terraform.Options) bool {
	flowLogID := terraform.Output(t, terraformOptions, "vpc_flow_log_id")
	flowLogGroup := terraform.Output(t, terraformOptions, "vpc_flow_log_group_name")

	return flowLogID != "" && flowLogGroup == "/aws/vpc/flowlogs"
}

func scanForRootAccountUsage(t *testing.T, iamSvc *iam.IAM) bool {
	// Check for root account access keys
	accessKeys, err := iamSvc.ListAccessKeys(&iam.ListAccessKeysInput{})
	require.NoError(t, err)

	for _, key := range accessKeys.AccessKeyMetadata {
		if *key.UserName == "<root_account>" {
			return true
		}
	}

	return false
}

func scanForUnusedIAMResources(t *testing.T, iamSvc *iam.IAM) []string {
	var unused []string

	// Check for users without recent activity
	users, err := iamSvc.ListUsers(&iam.ListUsersInput{})
	require.NoError(t, err)

	for _, user := range users.Users {
		// Check last used date
		lastUsed, err := iamSvc.GetUser(&iam.GetUserInput{
			UserName: user.UserName,
		})
		require.NoError(t, err)

		if lastUsed.User.PasswordLastUsed != nil {
			daysSinceLastUse := time.Since(*lastUsed.User.PasswordLastUsed).Hours() / 24
			if daysSinceLastUse > 90 { // 90 days threshold
				unused = append(unused, *user.UserName)
			}
		}
	}

	return unused
}

func verifyPasswordPolicy(t *testing.T, iamSvc *iam.IAM) bool {
	policy, err := iamSvc.GetAccountPasswordPolicy(&iam.GetAccountPasswordPolicyInput{})
	if err != nil {
		return false
	}

	return *policy.PasswordPolicy.MinimumPasswordLength >= 8 &&
		*policy.PasswordPolicy.RequireSymbols &&
		*policy.PasswordPolicy.RequireNumbers &&
		*policy.PasswordPolicy.RequireUppercaseCharacters &&
		*policy.PasswordPolicy.RequireLowercaseCharacters
}

func scanForCISCompliance(t *testing.T, terraformOptions *terraform.Options) []string {
	var violations []string

	// Check various CIS compliance items
	encryptionEnabled := terraform.Output(t, terraformOptions, "encryption_enabled")
	if encryptionEnabled != "true" {
		violations = append(violations, "CIS-2.2.1: Encryption not enabled")
	}

	monitoringEnabled := terraform.Output(t, terraformOptions, "detailed_monitoring_enabled")
	if monitoringEnabled != "true" {
		violations = append(violations, "CIS-2.2.2: Detailed monitoring not enabled")
	}

	return violations
}

func verifySecurityHeaders(t *testing.T, terraformOptions *terraform.Options) bool {
	// This would check if security headers are configured in the web server
	// For this test, we'll assume they're configured if the user data script exists
	userDataConfigured := terraform.Output(t, terraformOptions, "user_data_configured")
	return userDataConfigured == "true"
}

func verifyLoggingConfiguration(t *testing.T, terraformOptions *terraform.Options) bool {
	cloudTrailEnabled := terraform.Output(t, terraformOptions, "cloudtrail_enabled")
	vpcFlowLogsEnabled := terraform.Output(t, terraformOptions, "vpc_flow_logs_enabled")

	return cloudTrailEnabled == "true" && vpcFlowLogsEnabled == "true"
}
