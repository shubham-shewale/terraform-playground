package security

import (
	"fmt"
	"net/http"
	"strings"
	"testing"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/cloudfront"
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/aws/aws-sdk-go/service/wafv2"
	"github.com/gruntwork-io/terratest/modules/terraform"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestWebsiteVulnerabilityScan(t *testing.T) {
	t.Parallel()

	terraformOptions := &terraform.Options{
		TerraformDir: "../../",
		Vars: map[string]interface{}{
			"domain_name": "security-test.example.com",
		},
	}

	defer terraform.Destroy(t, terraformOptions)
	terraform.InitAndApply(t, terraformOptions)

	// Get infrastructure details
	cloudfrontDomain := terraform.Output(t, terraformOptions, "cloudfront_domain")
	s3BucketName := terraform.Output(t, terraformOptions, "s3_bucket_name")
	wafACLArn := terraform.Output(t, terraformOptions, "waf_web_acl_arn")

	sess := session.Must(session.NewSession(&aws.Config{
		Region: aws.String("us-east-1"),
	}))

	// Test 1: Check for exposed S3 bucket
	t.Log("Scanning for S3 bucket exposure...")
	exposedBuckets := scanForExposedS3Buckets(t, sess, s3BucketName)
	assert.Empty(t, exposedBuckets, "S3 bucket should not be publicly accessible")

	// Test 2: Check CloudFront security headers
	t.Log("Scanning CloudFront security headers...")
	securityHeaders := scanCloudFrontSecurityHeaders(t, cloudfrontDomain)
	assert.True(t, securityHeaders, "Security headers should be properly configured")

	// Test 3: Check WAF protection effectiveness
	t.Log("Scanning WAF protection...")
	wafProtection := scanWAFProtection(t, sess, wafACLArn)
	assert.True(t, wafProtection, "WAF should provide adequate protection")

	// Test 4: Check for HTTPS enforcement
	t.Log("Scanning HTTPS enforcement...")
	httpsEnforced := scanHTTPSEnforcement(t, cloudfrontDomain)
	assert.True(t, httpsEnforced, "HTTPS should be enforced")

	// Test 5: Check for common web vulnerabilities
	t.Log("Scanning for common web vulnerabilities...")
	vulnerabilities := scanForWebVulnerabilities(t, cloudfrontDomain)
	assert.Empty(t, vulnerabilities, "No common web vulnerabilities should be present")
}

func TestCloudFrontSecurityScan(t *testing.T) {
	t.Parallel()

	terraformOptions := &terraform.Options{
		TerraformDir: "../../",
		Vars: map[string]interface{}{
			"domain_name": "security-test.example.com",
		},
	}

	defer terraform.Destroy(t, terraformOptions)
	terraform.InitAndApply(t, terraformOptions)

	distributionID := terraform.Output(t, terraformOptions, "cloudfront_distribution_id")

	sess := session.Must(session.NewSession(&aws.Config{
		Region: aws.String("us-east-1"),
	}))
	cloudfrontSvc := cloudfront.New(sess)

	// Test 1: Check distribution configuration security
	t.Log("Scanning CloudFront distribution security...")

	distResult, err := cloudfrontSvc.GetDistribution(&cloudfront.GetDistributionInput{
		Id: aws.String(distributionID),
	})
	require.NoError(t, err)

	config := distResult.Distribution.DistributionConfig

	// Check HTTPS enforcement
	assert.True(t, *config.DefaultCacheBehavior.ViewerProtocolPolicy == "redirect-to-https" ||
		*config.DefaultCacheBehavior.ViewerProtocolPolicy == "https-only",
		"HTTPS should be enforced")

	// Check minimum TLS version
	if config.DefaultCacheBehavior.MinTTL != nil {
		assert.GreaterOrEqual(t, *config.DefaultCacheBehavior.MinTTL, int64(0), "Minimum TTL should be configured")
	}

	// Test 2: Check origin access control
	t.Log("Scanning origin access control...")
	assert.NotEmpty(t, config.Origins.Items, "Origins should be configured")

	for _, origin := range config.Origins.Items {
		if origin.S3OriginConfig != nil {
			assert.NotNil(t, origin.S3OriginConfig.OriginAccessIdentity, "Origin Access Identity should be configured")
		}
	}
}

func TestWAFSecurityScan(t *testing.T) {
	t.Parallel()

	terraformOptions := &terraform.Options{
		TerraformDir: "../../",
		Vars: map[string]interface{}{
			"domain_name": "security-test.example.com",
		},
	}

	defer terraform.Destroy(t, terraformOptions)
	terraform.InitAndApply(t, terraformOptions)

	wafACLArn := terraform.Output(t, terraformOptions, "waf_web_acl_arn")

	sess := session.Must(session.NewSession(&aws.Config{
		Region: aws.String("us-east-1"),
	}))
	wafSvc := wafv2.New(sess)

	// Test 1: Check WAF rule configuration
	t.Log("Scanning WAF rule configuration...")

	wafResult, err := wafSvc.GetWebACL(&wafv2.GetWebACLInput{
		Id:    aws.String(extractWAFIDFromArn(wafACLArn)),
		Scope: aws.String("CLOUDFRONT"),
	})
	require.NoError(t, err)

	rules := wafResult.WebACL.Rules
	assert.Greater(t, len(rules), 0, "WAF should have rules configured")

	// Check for essential rule groups
	hasCommonRules := false
	hasSQLiRules := false
	hasXSSRules := false

	for _, rule := range rules {
		if rule.Statement.ManagedRuleGroupStatement != nil {
			ruleName := *rule.Statement.ManagedRuleGroupStatement.Name
			switch {
			case strings.Contains(ruleName, "AWSManagedRulesCommonRuleSet"):
				hasCommonRules = true
			case strings.Contains(ruleName, "AWSManagedRulesSQLiRuleSet"):
				hasSQLiRules = true
			case strings.Contains(ruleName, "AWSManagedRulesKnownBadInputsRuleSet"):
				hasXSSRules = true
			}
		}
	}

	assert.True(t, hasCommonRules, "WAF should include common rules")
	assert.True(t, hasSQLiRules, "WAF should include SQL injection protection")
	assert.True(t, hasXSSRules, "WAF should include XSS protection")

	// Test 2: Check rate limiting
	t.Log("Scanning WAF rate limiting...")
	hasRateLimit := false
	for _, rule := range rules {
		if rule.Statement.RateBasedStatement != nil {
			hasRateLimit = true
			break
		}
	}
	assert.True(t, hasRateLimit, "WAF should include rate limiting")
}

func TestS3SecurityScan(t *testing.T) {
	t.Parallel()

	terraformOptions := &terraform.Options{
		TerraformDir: "../../",
		Vars: map[string]interface{}{
			"domain_name": "security-test.example.com",
		},
	}

	defer terraform.Destroy(t, terraformOptions)
	terraform.InitAndApply(t, terraformOptions)

	s3BucketName := terraform.Output(t, terraformOptions, "s3_bucket_name")

	sess := session.Must(session.NewSession(&aws.Config{
		Region: aws.String("us-east-1"),
	}))
	s3Svc := s3.New(sess)

	// Test 1: Check bucket public access
	t.Log("Scanning S3 bucket public access...")

	publicAccessResult, err := s3Svc.GetPublicAccessBlock(&s3.GetPublicAccessBlockInput{
		Bucket: aws.String(s3BucketName),
	})
	require.NoError(t, err)

	block := publicAccessResult.PublicAccessBlockConfiguration
	assert.True(t, *block.BlockPublicAcls, "Public ACLs should be blocked")
	assert.True(t, *block.BlockPublicPolicy, "Public policies should be blocked")
	assert.True(t, *block.IgnorePublicAcls, "Public ACLs should be ignored")
	assert.True(t, *block.RestrictPublicBuckets, "Public bucket access should be restricted")

	// Test 2: Check server-side encryption
	t.Log("Scanning S3 encryption configuration...")

	encryptionResult, err := s3Svc.GetBucketEncryption(&s3.GetBucketEncryptionInput{
		Bucket: aws.String(s3BucketName),
	})
	require.NoError(t, err)

	assert.NotEmpty(t, encryptionResult.ServerSideEncryptionConfiguration, "SSE should be configured")

	// Test 3: Check bucket policy
	t.Log("Scanning S3 bucket policy...")

	policyResult, err := s3Svc.GetBucketPolicy(&s3.GetBucketPolicyInput{
		Bucket: aws.String(s3BucketName),
	})
	require.NoError(t, err)

	assert.NotEmpty(t, policyResult.Policy, "Bucket policy should be configured")
	assert.Contains(t, *policyResult.Policy, "cloudfront", "Policy should allow CloudFront access")
}

func TestCertificateSecurityScan(t *testing.T) {
	t.Parallel()

	terraformOptions := &terraform.Options{
		TerraformDir: "../../",
		Vars: map[string]interface{}{
			"domain_name": "security-test.example.com",
		},
	}

	defer terraform.Destroy(t, terraformOptions)
	terraform.InitAndApply(t, terraformOptions)

	cloudfrontDomain := terraform.Output(t, terraformOptions, "cloudfront_domain")

	// Test 1: Check SSL/TLS configuration
	t.Log("Scanning SSL/TLS configuration...")

	resp, err := http.Get(fmt.Sprintf("https://%s", cloudfrontDomain))
	require.NoError(t, err)
	defer resp.Body.Close()

	assert.Equal(t, 200, resp.StatusCode)

	// Test 2: Check certificate validity
	t.Log("Scanning certificate validity...")

	// In a real scenario, you would check certificate expiration
	// For this test, we verify HTTPS is working
	assert.Equal(t, "https", resp.Request.URL.Scheme, "HTTPS should be used")

	// Test 3: Check HTTP to HTTPS redirect
	t.Log("Scanning HTTP redirect...")

	httpResp, err := http.Get(fmt.Sprintf("http://%s", cloudfrontDomain))
	if err == nil {
		defer httpResp.Body.Close()
		assert.Equal(t, 301, httpResp.StatusCode, "HTTP should redirect to HTTPS")
		location := httpResp.Header.Get("Location")
		assert.Contains(t, location, "https://", "Redirect should be to HTTPS")
	}
}

func TestContentSecurityScan(t *testing.T) {
	t.Parallel()

	terraformOptions := &terraform.Options{
		TerraformDir: "../../",
		Vars: map[string]interface{}{
			"domain_name": "security-test.example.com",
		},
	}

	defer terraform.Destroy(t, terraformOptions)
	terraform.InitAndApply(t, terraformOptions)

	cloudfrontDomain := terraform.Output(t, terraformOptions, "cloudfront_domain")

	// Test 1: Check security headers
	t.Log("Scanning security headers...")

	resp, err := http.Get(fmt.Sprintf("https://%s", cloudfrontDomain))
	require.NoError(t, err)
	defer resp.Body.Close()

	// Check essential security headers
	headers := resp.Header
	expectedHeaders := map[string]string{
		"X-Frame-Options":           "DENY",
		"X-Content-Type-Options":    "nosniff",
		"X-XSS-Protection":          "1; mode=block",
		"Strict-Transport-Security": "max-age=",
		"Content-Security-Policy":   "default-src",
	}

	for header, expectedValue := range expectedHeaders {
		actualValue := headers.Get(header)
		assert.NotEmpty(t, actualValue, "Security header %s should be present", header)
		if expectedValue != "" {
			assert.Contains(t, actualValue, expectedValue, "Security header %s should contain %s", header, expectedValue)
		}
	}

	// Test 2: Check for information disclosure
	t.Log("Scanning for information disclosure...")

	server := headers.Get("Server")
	xPoweredBy := headers.Get("X-Powered-By")

	// Server header should not reveal sensitive information
	if server != "" {
		assert.NotContains(t, strings.ToLower(server), "apache", "Server header should not reveal web server type")
		assert.NotContains(t, strings.ToLower(server), "nginx", "Server header should not reveal web server type")
	}

	assert.Empty(t, xPoweredBy, "X-Powered-By header should not be present")
}

// Helper functions for security scanning

func scanForExposedS3Buckets(t *testing.T, sess *session.Session, bucketName string) []string {
	s3Svc := s3.New(sess)

	var exposed []string

	// Check bucket public access block
	publicAccessResult, err := s3Svc.GetPublicAccessBlock(&s3.GetPublicAccessBlockInput{
		Bucket: aws.String(bucketName),
	})
	if err == nil {
		block := publicAccessResult.PublicAccessBlockConfiguration
		if !*block.BlockPublicAcls || !*block.BlockPublicPolicy {
			exposed = append(exposed, bucketName)
		}
	}

	return exposed
}

func scanCloudFrontSecurityHeaders(t *testing.T, domain string) bool {
	resp, err := http.Get(fmt.Sprintf("https://%s", domain))
	if err != nil {
		return false
	}
	defer resp.Body.Close()

	headers := resp.Header

	// Check for essential security headers
	requiredHeaders := []string{
		"X-Frame-Options",
		"X-Content-Type-Options",
		"X-XSS-Protection",
		"Strict-Transport-Security",
		"Content-Security-Policy",
	}

	for _, header := range requiredHeaders {
		if headers.Get(header) == "" {
			return false
		}
	}

	return true
}

func scanWAFProtection(t *testing.T, sess *session.Session, wafACLArn string) bool {
	wafSvc := wafv2.New(sess)

	wafResult, err := wafSvc.GetWebACL(&wafv2.GetWebACLInput{
		Id:    aws.String(extractWAFIDFromArn(wafACLArn)),
		Scope: aws.String("CLOUDFRONT"),
	})
	if err != nil {
		return false
	}

	rules := wafResult.WebACL.Rules
	if len(rules) < 3 { // Should have at least basic protection rules
		return false
	}

	// Check for rate limiting
	hasRateLimit := false
	for _, rule := range rules {
		if rule.Statement.RateBasedStatement != nil {
			hasRateLimit = true
			break
		}
	}

	return hasRateLimit
}

func scanHTTPSEnforcement(t *testing.T, domain string) bool {
	// Test HTTPS access
	httpsResp, err := http.Get(fmt.Sprintf("https://%s", domain))
	if err != nil {
		return false
	}
	defer httpsResp.Body.Close()

	if httpsResp.StatusCode != 200 {
		return false
	}

	// Test HTTP redirect
	httpResp, err := http.Get(fmt.Sprintf("http://%s", domain))
	if err == nil {
		defer httpResp.Body.Close()
		return httpResp.StatusCode == 301 && strings.Contains(httpResp.Header.Get("Location"), "https://")
	}

	return false
}

func scanForWebVulnerabilities(t *testing.T, domain string) []string {
	var vulnerabilities []string

	// Test for common vulnerabilities
	tests := []struct {
		name  string
		url   string
		check func(*http.Response) bool
	}{
		{
			name: "Directory traversal",
			url:  fmt.Sprintf("https://%s/../../../etc/passwd", domain),
			check: func(resp *http.Response) bool {
				return resp.StatusCode == 200
			},
		},
		{
			name: "SQL injection",
			url:  fmt.Sprintf("https://%s/?id=1'", domain),
			check: func(resp *http.Response) bool {
				return resp.StatusCode == 200 && strings.Contains(resp.Header.Get("Content-Type"), "text/html")
			},
		},
	}

	for _, test := range tests {
		resp, err := http.Get(test.url)
		if err == nil {
			defer resp.Body.Close()
			if test.check(resp) {
				vulnerabilities = append(vulnerabilities, test.name)
			}
		}
	}

	return vulnerabilities
}

func extractWAFIDFromArn(arn string) string {
	// ARN format: arn:aws:wafv2:region:account:regional/webacl/name/id
	parts := strings.Split(arn, "/")
	if len(parts) >= 3 {
		return parts[2]
	}
	return ""
}

// Helper function to extract WAF name from ARN
func extractWAFNameFromArn(arn string) string {
	// ARN format: arn:aws:wafv2:region:account:regional/webacl/name/id
	parts := strings.Split(arn, "/")
	if len(parts) >= 2 {
		return parts[1]
	}
	return ""
}
